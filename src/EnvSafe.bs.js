// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S$RescriptSchema = require("rescript-schema/src/S.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function alert(message) {
  if ((typeof window !== 'undefined' && window.alert)) {
    return (window.alert(message));
  }
  
}

function mixinMissingIssue(envSafe, issue) {
  var missingIssues = envSafe.maybeMissingIssues;
  if (missingIssues !== undefined) {
    missingIssues.push(issue);
  } else {
    envSafe.maybeMissingIssues = [issue];
  }
}

function mixinInvalidIssue(envSafe, issue) {
  var invalidIssues = envSafe.maybeInvalidIssues;
  if (invalidIssues !== undefined) {
    invalidIssues.push(issue);
  } else {
    envSafe.maybeInvalidIssues = [issue];
  }
}

function make(envOpt) {
  var env = envOpt !== undefined ? envOpt : process.env;
  return {
          env: env,
          isLocked: false,
          maybeMissingIssues: undefined,
          maybeInvalidIssues: undefined
        };
}

function close(envSafe) {
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is already closed.");
  }
  envSafe.isLocked = true;
  var match = envSafe.maybeMissingIssues;
  var match$1 = envSafe.maybeInvalidIssues;
  if (match === undefined && match$1 === undefined) {
    return ;
  }
  var line = "========================================";
  var output = [line];
  var fn = function (invalidIssues) {
    output.push("‚ùå Invalid environment variables:");
    invalidIssues.forEach(function (issue) {
          output.push("    " + issue.name + ": " + S$RescriptSchema.$$Error.message(issue.error));
        });
  };
  if (match$1 !== undefined) {
    fn(Caml_option.valFromOption(match$1));
  }
  var fn$1 = function (missingIssues) {
    output.push("üí® Missing environment variables:");
    missingIssues.forEach(function (issue) {
          var match = issue.input;
          var tmp;
          tmp = match === "" ? "Disallowed empty string" : "Missing value";
          output.push("    " + issue.name + ": " + tmp);
        });
  };
  if (match !== undefined) {
    fn$1(Caml_option.valFromOption(match));
  }
  output.push(line);
  var text = output.join("\n");
  console.error(text);
  alert(text);
  throw new TypeError(text);
}

function boolCoerce(string) {
  switch (string) {
    case "0" :
    case "f" :
    case "false" :
        return false;
    case "1" :
    case "t" :
    case "true" :
        return true;
    default:
      return string;
  }
}

function numberCoerce(string) {
  var $$float = (+string);
  if (Number.isNaN($$float)) {
    return string;
  } else {
    return $$float;
  }
}

function bigintCoerce(string) {
  try {
    return BigInt(string);
  }
  catch (exn){
    return string;
  }
}

function jsonCoerce(string) {
  try {
    return JSON.parse(string);
  }
  catch (exn){
    return string;
  }
}

function get(envSafe, name, schema, allowEmptyOpt, maybeFallback, maybeDevFallback, maybeInlinedInput) {
  var allowEmpty = allowEmptyOpt !== undefined ? allowEmptyOpt : false;
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is closed. Make a new one to get access to environment variables.");
  }
  var input = maybeInlinedInput !== undefined ? Caml_option.valFromOption(maybeInlinedInput) : envSafe.env[name];
  var isMissing = input !== undefined && !(input === "" && !allowEmpty) ? false : true;
  var match = schema.t;
  var isOptional;
  isOptional = typeof match !== "object" || match.TAG !== "option" ? false : true;
  if (isMissing && !isOptional) {
    if (maybeDevFallback !== undefined && envSafe.env["NODE_ENV"] !== "production") {
      return Caml_option.valFromOption(maybeDevFallback);
    }
    if (maybeFallback !== undefined) {
      return Caml_option.valFromOption(maybeFallback);
    } else {
      mixinMissingIssue(envSafe, {
            name: name,
            input: input
          });
      return undefined;
    }
  }
  var optionalSchema = schema.t;
  var tagged;
  tagged = typeof optionalSchema !== "object" || optionalSchema.TAG !== "option" ? optionalSchema : optionalSchema._0.t;
  var input$1;
  if (input !== undefined) {
    var exit = 0;
    if (input === "" && !allowEmpty) {
      input$1 = undefined;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var tmp;
      if (typeof tagged !== "object") {
        switch (tagged) {
          case "never" :
          case "string" :
              tmp = input;
              break;
          case "int32" :
          case "number" :
              tmp = numberCoerce(input);
              break;
          case "bigint" :
              tmp = bigintCoerce(input);
              break;
          case "boolean" :
              tmp = boolCoerce(input);
              break;
          default:
            tmp = jsonCoerce(input);
        }
      } else {
        switch (tagged.TAG) {
          case "literal" :
              switch (tagged._0.kind) {
                case "String" :
                    tmp = input;
                    break;
                case "Number" :
                    tmp = numberCoerce(input);
                    break;
                case "Boolean" :
                    tmp = boolCoerce(input);
                    break;
                case "BigInt" :
                    tmp = bigintCoerce(input);
                    break;
                default:
                  tmp = jsonCoerce(input);
              }
              break;
          case "union" :
              tmp = input;
              break;
          default:
            tmp = jsonCoerce(input);
        }
      }
      input$1 = tmp;
    }
    
  } else {
    input$1 = undefined;
  }
  var schema$1;
  schema$1 = typeof tagged !== "object" || tagged.TAG !== "union" ? schema : S$RescriptSchema.preprocess(schema, (function (s) {
            var optionalSchema = s.schema.t;
            var tagged;
            tagged = typeof optionalSchema !== "object" || optionalSchema.TAG !== "option" ? optionalSchema : optionalSchema._0.t;
            var exit = 0;
            if (typeof tagged !== "object") {
              switch (tagged) {
                case "never" :
                case "string" :
                    return {};
                case "int32" :
                case "number" :
                    exit = 4;
                    break;
                case "bigint" :
                    exit = 3;
                    break;
                case "boolean" :
                    exit = 2;
                    break;
                default:
                  exit = 1;
              }
            } else {
              switch (tagged.TAG) {
                case "literal" :
                    switch (tagged._0.kind) {
                      case "String" :
                          return {};
                      case "Number" :
                          exit = 4;
                          break;
                      case "Boolean" :
                          exit = 2;
                          break;
                      case "BigInt" :
                          exit = 3;
                          break;
                      default:
                        exit = 1;
                    }
                    break;
                case "union" :
                    return {};
                default:
                  exit = 1;
              }
            }
            switch (exit) {
              case 1 :
                  return {
                          p: (function (unknown) {
                              return jsonCoerce(unknown);
                            })
                        };
              case 2 :
                  return {
                          p: (function (unknown) {
                              return boolCoerce(unknown);
                            })
                        };
              case 3 :
                  return {
                          p: (function (unknown) {
                              return bigintCoerce(unknown);
                            })
                        };
              case 4 :
                  return {
                          p: (function (unknown) {
                              return numberCoerce(unknown);
                            })
                        };
              
            }
          }));
  try {
    return S$RescriptSchema.parseOrThrow(input$1, schema$1);
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptSchema.Raised) {
      mixinInvalidIssue(envSafe, {
            name: name,
            error: error._1,
            input: input$1
          });
      return undefined;
    }
    throw error;
  }
}

exports.make = make;
exports.close = close;
exports.get = get;
/* S-RescriptSchema Not a pure module */
