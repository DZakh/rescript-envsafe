// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S$RescriptSchema = require("rescript-schema/src/S.bs.js");

function alert(message) {
  if ((typeof window !== 'undefined' && window.alert)) {
    return (window.alert(message));
  }
  
}

function mixinIssue(envSafe, issue) {
  var match = issue.error;
  var match$1 = match.code;
  var exit = 0;
  if (typeof match$1 === "object") {
    switch (match$1.TAG) {
      case "InvalidType" :
      case "InvalidLiteral" :
          exit = 2;
          break;
      default:
        
    }
  }
  if (exit === 2 && match$1.received === undefined) {
    var missingIssues = envSafe.maybeMissingIssues;
    if (missingIssues !== undefined) {
      missingIssues.push(issue);
    } else {
      envSafe.maybeMissingIssues = [issue];
    }
    return ;
  }
  var invalidIssues = envSafe.maybeInvalidIssues;
  if (invalidIssues !== undefined) {
    invalidIssues.push(issue);
  } else {
    envSafe.maybeInvalidIssues = [issue];
  }
}

function make(envOpt) {
  var env = envOpt !== undefined ? envOpt : process.env;
  return {
          env: env,
          isLocked: false,
          maybeMissingIssues: undefined,
          maybeInvalidIssues: undefined
        };
}

function close(envSafe) {
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is already closed.");
  }
  envSafe.isLocked = true;
  var match = envSafe.maybeMissingIssues;
  var match$1 = envSafe.maybeInvalidIssues;
  if (match === undefined && match$1 === undefined) {
    return ;
  }
  var line = "========================================";
  var output = [line];
  var fn = function (invalidIssues) {
    output.push("‚ùå Invalid environment variables:");
    invalidIssues.forEach(function (issue) {
          output.push("    " + issue.name + ": " + S$RescriptSchema.$$Error.message(issue.error));
        });
  };
  if (match$1 !== undefined) {
    fn(Caml_option.valFromOption(match$1));
  }
  var fn$1 = function (missingIssues) {
    output.push("üí® Missing environment variables:");
    missingIssues.forEach(function (issue) {
          var match = issue.input;
          var tmp;
          tmp = match === "" ? "Disallowed empty string" : "Missing value";
          output.push("    " + issue.name + ": " + tmp);
        });
  };
  if (match !== undefined) {
    fn$1(Caml_option.valFromOption(match));
  }
  output.push(line);
  var text = output.join("\n");
  console.error(text);
  alert(text);
  throw new TypeError(text);
}

function get(envSafe, name, schema, allowEmptyOpt, maybeFallback, maybeDevFallback, maybeInlinedInput) {
  var allowEmpty = allowEmptyOpt !== undefined ? allowEmptyOpt : false;
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is closed. Make a new one to get access to environment variables.");
  }
  var input = maybeInlinedInput !== undefined ? Caml_option.valFromOption(maybeInlinedInput) : envSafe.env[name];
  var parseResult = S$RescriptSchema.parseAnyWith(input, S$RescriptSchema.preprocess(schema, (function (s) {
              var optionalSchema = S$RescriptSchema.classify(s.schema);
              var tagged;
              tagged = typeof optionalSchema !== "object" || optionalSchema.TAG !== "Option" ? optionalSchema : S$RescriptSchema.classify(optionalSchema._0);
              var exit = 0;
              if (typeof tagged !== "object") {
                switch (tagged) {
                  case "String" :
                      if (allowEmpty === false) {
                        return {
                                p: (function (unknown) {
                                    if (unknown === "") {
                                      return ;
                                    } else {
                                      return unknown;
                                    }
                                  })
                              };
                      } else {
                        return {};
                      }
                  case "Int" :
                  case "Float" :
                      exit = 3;
                      break;
                  case "Bool" :
                      exit = 2;
                      break;
                  case "Never" :
                  case "Unknown" :
                  case "JSON" :
                      return {};
                  
                }
              } else {
                switch (tagged.TAG) {
                  case "Literal" :
                      var tmp = tagged._0;
                      if (typeof tmp !== "object") {
                        exit = 1;
                      } else {
                        switch (tmp.TAG) {
                          case "String" :
                              return {};
                          case "Number" :
                              exit = 3;
                              break;
                          case "Boolean" :
                              exit = 2;
                              break;
                          default:
                            exit = 1;
                        }
                      }
                      break;
                  case "Union" :
                      return {};
                  default:
                    exit = 1;
                }
              }
              switch (exit) {
                case 1 :
                    return {
                            p: (function (unknown) {
                                if (typeof unknown === "string") {
                                  return JSON.parse(unknown);
                                } else {
                                  return unknown;
                                }
                              })
                          };
                case 2 :
                    return {
                            p: (function (unknown) {
                                switch (unknown) {
                                  case "0" :
                                  case "f" :
                                  case "false" :
                                      return false;
                                  case "1" :
                                  case "t" :
                                  case "true" :
                                      return true;
                                  default:
                                    return unknown;
                                }
                              })
                          };
                case 3 :
                    return {
                            p: (function (unknown) {
                                if (typeof unknown !== "string") {
                                  return unknown;
                                }
                                var $$float = (+unknown);
                                if (Number.isNaN($$float)) {
                                  return unknown;
                                } else {
                                  return $$float;
                                }
                              })
                          };
                
              }
            })));
  var exit = 0;
  if (parseResult.TAG === "Ok") {
    return parseResult._0;
  }
  var match = parseResult._0.code;
  var exit$1 = 0;
  if (typeof match === "object") {
    switch (match.TAG) {
      case "InvalidType" :
      case "InvalidLiteral" :
          exit$1 = 3;
          break;
      default:
        
    }
  }
  if (exit$1 === 3) {
    if (maybeDevFallback !== undefined) {
      if (match.received === undefined && envSafe.env["NODE_ENV"] !== "production") {
        return Caml_option.valFromOption(maybeDevFallback);
      }
      exit = 2;
    } else {
      exit = 2;
    }
  }
  if (exit === 2 && maybeFallback !== undefined && parseResult._0.code.received === undefined) {
    return Caml_option.valFromOption(maybeFallback);
  }
  mixinIssue(envSafe, {
        name: name,
        error: parseResult._0,
        input: input
      });
  return undefined;
}

exports.make = make;
exports.close = close;
exports.get = get;
/* S-RescriptSchema Not a pure module */
