// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S$RescriptStruct = require("rescript-struct/src/S.bs.js");

function alert(message) {
  if ((typeof window !== 'undefined' && window.alert)) {
    return (window.alert(message));
  }
  
}

function mixinIssue(envSafe, issue) {
  var match = issue.error;
  var match$1 = match.code;
  if (typeof match$1 !== "number" && match$1.TAG === /* UnexpectedType */1 && match$1.received === "Option") {
    var missingIssues = envSafe.maybeMissingIssues;
    if (missingIssues !== undefined) {
      missingIssues.push(issue);
    } else {
      envSafe.maybeMissingIssues = [issue];
    }
    return ;
  }
  var invalidIssues = envSafe.maybeInvalidIssues;
  if (invalidIssues !== undefined) {
    invalidIssues.push(issue);
  } else {
    envSafe.maybeInvalidIssues = [issue];
  }
}

function make(envOpt, param) {
  var env = envOpt !== undefined ? Caml_option.valFromOption(envOpt) : process.env;
  return {
          env: env,
          isLocked: false,
          maybeMissingIssues: undefined,
          maybeInvalidIssues: undefined
        };
}

function close(envSafe, param) {
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is already closed.");
  }
  envSafe.isLocked = true;
  var match = envSafe.maybeMissingIssues;
  var match$1 = envSafe.maybeInvalidIssues;
  if (match === undefined && match$1 === undefined) {
    return ;
  }
  var line = "========================================";
  var output = [line];
  if (match$1 !== undefined) {
    var invalidIssues = Caml_option.valFromOption(match$1);
    output.push("‚ùå Invalid environment variables:");
    invalidIssues.forEach(function (issue) {
          var v = issue.input;
          output.push("    " + issue.name + "" + (
                v !== undefined ? " (\"" + v + "\")" : ""
              ) + ": " + S$RescriptStruct.$$Error.toString(issue.error) + "");
        });
  }
  if (match !== undefined) {
    var missingIssues = Caml_option.valFromOption(match);
    output.push("üí® Missing environment variables:");
    missingIssues.forEach(function (issue) {
          var match = issue.input;
          var tmp;
          tmp = match === "" ? "Disallowed empty string" : "Missing value";
          output.push("    " + issue.name + ": " + tmp + "");
        });
  }
  output.push(line);
  var text = output.join("\n");
  console.error(text);
  alert(text);
  throw new TypeError(text);
}

function get(envSafe, name, struct, allowEmptyOpt, maybeDevFallback, maybeInlinedInput, param) {
  var allowEmpty = allowEmptyOpt !== undefined ? allowEmptyOpt : false;
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is closed. Make a new one to get access to environment variables.");
  }
  var input = maybeInlinedInput !== undefined ? Caml_option.valFromOption(maybeInlinedInput) : envSafe.env[name];
  var parseResult = S$RescriptStruct.parseAnyWith(input, S$RescriptStruct.advancedPreprocess(struct, (function (struct) {
              var optionalStruct = S$RescriptStruct.classify(struct);
              var tagged;
              tagged = typeof optionalStruct === "number" || optionalStruct.TAG !== /* Option */1 ? optionalStruct : S$RescriptStruct.classify(optionalStruct._0);
              var exit = 0;
              if (typeof tagged === "number") {
                switch (tagged) {
                  case /* String */2 :
                      if (allowEmpty === false) {
                        return {
                                TAG: /* Sync */0,
                                _0: (function (unknown) {
                                    if (unknown === "") {
                                      return ;
                                    } else {
                                      return unknown;
                                    }
                                  })
                              };
                      }
                      exit = 1;
                      break;
                  case /* Int */3 :
                  case /* Float */4 :
                      exit = 3;
                      break;
                  case /* Bool */5 :
                      exit = 2;
                      break;
                  default:
                    exit = 1;
                }
              } else if (tagged.TAG === /* Literal */0) {
                var tmp = tagged._0;
                if (typeof tmp === "number") {
                  exit = 1;
                } else {
                  switch (tmp.TAG | 0) {
                    case /* Int */1 :
                    case /* Float */2 :
                        exit = 3;
                        break;
                    case /* Bool */3 :
                        exit = 2;
                        break;
                    default:
                      exit = 1;
                  }
                }
              } else {
                exit = 1;
              }
              switch (exit) {
                case 1 :
                    return {
                            TAG: /* Sync */0,
                            _0: (function (unknown) {
                                return unknown;
                              })
                          };
                case 2 :
                    return {
                            TAG: /* Sync */0,
                            _0: (function (unknown) {
                                switch (unknown) {
                                  case "0" :
                                  case "f" :
                                  case "false" :
                                      return false;
                                  case "1" :
                                  case "t" :
                                  case "true" :
                                      return true;
                                  default:
                                    return unknown;
                                }
                              })
                          };
                case 3 :
                    return {
                            TAG: /* Sync */0,
                            _0: (function (unknown) {
                                if (typeof unknown === "string") {
                                  return (+unknown);
                                } else {
                                  return unknown;
                                }
                              })
                          };
                
              }
            }), undefined, undefined));
  if (parseResult.TAG === /* Ok */0) {
    return parseResult._0;
  }
  var error = parseResult._0;
  var match = error.code;
  if (typeof match !== "number" && match.TAG === /* UnexpectedType */1 && match.received === "Option" && maybeDevFallback !== undefined && envSafe.env["NODE_ENV"] !== "production") {
    return Caml_option.valFromOption(maybeDevFallback);
  }
  mixinIssue(envSafe, {
        name: name,
        error: error,
        input: input
      });
  return undefined;
}

exports.make = make;
exports.close = close;
exports.get = get;
/* No side effect */
