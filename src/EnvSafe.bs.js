// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S$RescriptSchema = require("rescript-schema/src/S.bs.js");

function alert(message) {
  if ((typeof window !== 'undefined' && window.alert)) {
    return (window.alert(message));
  }
  
}

function mixinMissingIssue(envSafe, issue) {
  var missingIssues = envSafe.maybeMissingIssues;
  if (missingIssues !== undefined) {
    missingIssues.push(issue);
  } else {
    envSafe.maybeMissingIssues = [issue];
  }
}

function mixinInvalidIssue(envSafe, issue) {
  var invalidIssues = envSafe.maybeInvalidIssues;
  if (invalidIssues !== undefined) {
    invalidIssues.push(issue);
  } else {
    envSafe.maybeInvalidIssues = [issue];
  }
}

function make(envOpt) {
  var env = envOpt !== undefined ? envOpt : process.env;
  return {
          env: env,
          isLocked: false,
          maybeMissingIssues: undefined,
          maybeInvalidIssues: undefined
        };
}

function close(envSafe) {
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is already closed.");
  }
  envSafe.isLocked = true;
  var match = envSafe.maybeMissingIssues;
  var match$1 = envSafe.maybeInvalidIssues;
  if (match === undefined && match$1 === undefined) {
    return ;
  }
  var line = "========================================";
  var output = [line];
  var fn = function (invalidIssues) {
    output.push("‚ùå Invalid environment variables:");
    invalidIssues.forEach(function (issue) {
          output.push("    " + issue.name + ": " + S$RescriptSchema.$$Error.message(issue.error));
        });
  };
  if (match$1 !== undefined) {
    fn(Caml_option.valFromOption(match$1));
  }
  var fn$1 = function (missingIssues) {
    output.push("üí® Missing environment variables:");
    missingIssues.forEach(function (issue) {
          var match = issue.input;
          var tmp;
          tmp = match === "" ? "Disallowed empty string" : "Missing value";
          output.push("    " + issue.name + ": " + tmp);
        });
  };
  if (match !== undefined) {
    fn$1(Caml_option.valFromOption(match));
  }
  output.push(line);
  var text = output.join("\n");
  console.error(text);
  alert(text);
  throw new TypeError(text);
}

function boolCoerce(string) {
  switch (string) {
    case "0" :
    case "f" :
    case "false" :
        return false;
    case "1" :
    case "t" :
    case "true" :
        return true;
    default:
      return string;
  }
}

function numberCoerce(string) {
  var $$float = (+string);
  if (Number.isNaN($$float)) {
    return string;
  } else {
    return $$float;
  }
}

function jsonCoerce(string) {
  try {
    return JSON.parse(string);
  }
  catch (exn){
    return string;
  }
}

function get(envSafe, name, schema, allowEmptyOpt, maybeFallback, maybeDevFallback, maybeInlinedInput) {
  var allowEmpty = allowEmptyOpt !== undefined ? allowEmptyOpt : false;
  if (envSafe.isLocked) {
    throw new Error("[rescript-envsafe] EnvSafe is closed. Make a new one to get access to environment variables.");
  }
  var input = maybeInlinedInput !== undefined ? Caml_option.valFromOption(maybeInlinedInput) : envSafe.env[name];
  var isMissing = input !== undefined && !(input === "" && !allowEmpty) ? false : true;
  var match = S$RescriptSchema.classify(schema);
  var isOptional;
  isOptional = typeof match !== "object" || match.TAG !== "Option" ? false : true;
  if (isMissing && !isOptional) {
    if (maybeDevFallback !== undefined && envSafe.env["NODE_ENV"] !== "production") {
      return Caml_option.valFromOption(maybeDevFallback);
    }
    if (maybeFallback !== undefined) {
      return Caml_option.valFromOption(maybeFallback);
    } else {
      mixinMissingIssue(envSafe, {
            name: name,
            input: input
          });
      return undefined;
    }
  }
  var optionalSchema = S$RescriptSchema.classify(schema);
  var tagged;
  tagged = typeof optionalSchema !== "object" || optionalSchema.TAG !== "Option" ? optionalSchema : S$RescriptSchema.classify(optionalSchema._0);
  var input$1;
  if (input !== undefined) {
    var exit = 0;
    if (input === "" && !allowEmpty) {
      input$1 = undefined;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var tmp;
      if (typeof tagged !== "object") {
        switch (tagged) {
          case "Never" :
          case "String" :
              tmp = input;
              break;
          case "Int" :
          case "Float" :
              tmp = numberCoerce(input);
              break;
          case "Bool" :
              tmp = boolCoerce(input);
              break;
          default:
            tmp = jsonCoerce(input);
        }
      } else {
        switch (tagged.TAG) {
          case "Literal" :
              var tmp$1 = tagged._0;
              if (typeof tmp$1 !== "object") {
                tmp = jsonCoerce(input);
              } else {
                switch (tmp$1.TAG) {
                  case "String" :
                      tmp = input;
                      break;
                  case "Number" :
                      tmp = numberCoerce(input);
                      break;
                  case "Boolean" :
                      tmp = boolCoerce(input);
                      break;
                  default:
                    tmp = jsonCoerce(input);
                }
              }
              break;
          case "Union" :
              tmp = input;
              break;
          default:
            tmp = jsonCoerce(input);
        }
      }
      input$1 = tmp;
    }
    
  } else {
    input$1 = undefined;
  }
  var schema$1;
  schema$1 = typeof tagged !== "object" || tagged.TAG !== "Union" ? schema : S$RescriptSchema.preprocess(schema, (function (s) {
            var optionalSchema = S$RescriptSchema.classify(s.schema);
            var tagged;
            tagged = typeof optionalSchema !== "object" || optionalSchema.TAG !== "Option" ? optionalSchema : S$RescriptSchema.classify(optionalSchema._0);
            var exit = 0;
            if (typeof tagged !== "object") {
              switch (tagged) {
                case "Never" :
                case "String" :
                    return {};
                case "Int" :
                case "Float" :
                    exit = 3;
                    break;
                case "Bool" :
                    exit = 2;
                    break;
                default:
                  exit = 1;
              }
            } else {
              switch (tagged.TAG) {
                case "Literal" :
                    var tmp = tagged._0;
                    if (typeof tmp !== "object") {
                      exit = 1;
                    } else {
                      switch (tmp.TAG) {
                        case "String" :
                            return {};
                        case "Number" :
                            exit = 3;
                            break;
                        case "Boolean" :
                            exit = 2;
                            break;
                        default:
                          exit = 1;
                      }
                    }
                    break;
                case "Union" :
                    return {};
                default:
                  exit = 1;
              }
            }
            switch (exit) {
              case 1 :
                  return {
                          p: (function (unknown) {
                              return jsonCoerce(unknown);
                            })
                        };
              case 2 :
                  return {
                          p: (function (unknown) {
                              return boolCoerce(unknown);
                            })
                        };
              case 3 :
                  return {
                          p: (function (unknown) {
                              return numberCoerce(unknown);
                            })
                        };
              
            }
          }));
  var parseResult = S$RescriptSchema.parseAnyWith(input$1, schema$1);
  if (parseResult.TAG === "Ok") {
    return parseResult._0;
  }
  mixinInvalidIssue(envSafe, {
        name: name,
        error: parseResult._0,
        input: input$1
      });
  return undefined;
}

exports.make = make;
exports.close = close;
exports.get = get;
/* S-RescriptSchema Not a pure module */
